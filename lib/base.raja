#
# Base lib for raja
#

# Wrapping builtin functions so that they can be overloaded.
# (builtin) functions cannot be overloaded.

string = (a) => __string(a)
print = (a) => __print(a)
get_args = (a) => __args(a)
get_unsafe = (a, b) => __index(a, b, true)
get = (a, b) => __index(a, b, false)
panic = (a) => __panic(a)

# Print with ending newline.
# Also stringyfies arguments
println = () => print("\n")
println = (a) => print(a.string() ++ "\n")
println = (a, b) => {
	as = a.string()
	bs = b.string()
	print(as ++ " " ++ bs ++ "\n")
}
println = (a, b, c) => {
	as = a.string()
	bs = b.string()
	cs = c.string()
	print(as ++ " " ++ bs ++ " " ++ cs ++ "\n")
}


# Run function over a, and return a.
#
# Useful in pipelines where you want to run IO or similar and want to keep the existing value
with_identity = (a, f) => {
	f(a)
	a
}

append = (a, b) => a ++ b

is = (a, b) => a == b


#
# Types
#


# Result type

alias Result =
		["ok", _]
	| ["error", _]

# functions on Result
map = (r:Result, f) => match r {
	["ok", _] -> ["ok", f(r.get_unsafe(1))]
	_ -> r
}

string = (r:Result) => match r {
	["ok", _] -> "Ok: " ++ {
		r.get_unsafe(1).string()
	}
	_ -> "Error: " ++ {
		r.get_unsafe(1).string()
	}
}
# Maybe type

alias Maybe =
		["some", _]
	| ["none"]

map = (m:Maybe, f) => match m {
	["some", _] -> ["some", f(m.get_unsafe(1))]
	_ -> m
}

string = (m:Maybe) => match m {
	["some", _] -> "Some: " ++ {
		m.get(1).string()
	}
	_ -> "None"
}

unwrap = (m:Maybe) => match m {
	["some", _] -> m.get_unsafe(1)
	_ -> panic("trying to unwrap none")
}
# Smaller types

alias Tuple = [_, _]

alias Bool = false | true

# alias Num = 


#
# List
#
# TODO: create type

length = (list) => {
	_length = (l, i) => match l.get(i) {
		["none"] -> i
		_ -> _length(l, (i + 1))
	}
	_length(list, 0)
}

map_list = (list, f) => {
	_map_list = (i) => {
		x = list.get(i)
		match x {
			["some", _] -> [f(x.get_unsafe(1))] ++ {
				_map_list(i + 1)
			}
			_ -> []
		}
	}
	_map_list(0)
}
