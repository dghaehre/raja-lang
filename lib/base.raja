#
# Base lib for raja
#

# Wrapping builtin functions so that they can be overloaded.
# (builtin) functions cannot be overloaded.

string = (a) => __string(a)
print = (a) => __print(a)
get_args = (a) => __args(a)
get_unsafe = (a, b) => __index(a, b, true)
get = (a, b) => __index(a, b, false)
exit = (a) => __exit(a)


# Print with ending newline.
# Also stringyfies arguments
println = () => print("\n")
println = (a) => print(a.string() ++ "\n")
println = (a, b) => {
	as = a.string()
	bs = b.string()
	print(as ++ " " ++ bs ++ "\n")
}
println = (a, b, c) => {
	as = a.string()
	bs = b.string()
	cs = c.string()
	print(as ++ " " ++ bs ++ " " ++ cs ++ "\n")
}

# Run function over a, and return a.
#
# Useful in pipelines where you want to run IO or similar and want to keep the existing value
with_identity = (a, f) => {
	f(a)
	a
}

append = (a, b) => a ++ b

is = (a, b) => a == b

panic = (a) => {
	println("Panic: ", a)
	exit(1)
}

assert = (a, b) => match (a == b) {
	false -> {
		aa = a.string()
		bb = b.string()
		x = aa ++ " == " ++ bb
		println("Assert failed: ", x)
		exit(1)
	}
	_ -> true
}

#
# Types
#

# Builtin types:

# alias Int
# alias Float
# alias Str
# alias List

alias Tuple = [_, _]

alias Bool = false | true

alias Num = Int | Float



# Result

alias Result =
		Result::Ok(_)
	| Result::Err(_)

to_ok = (a) => Result::Ok(a)

map = (r:Result, f:Fn) => match r {
	Result::Ok(_) -> Result::Ok(f(r.get_unsafe(0)))
	_							-> r
}

map_err = (r:Result, f:Fn) => match r {
	Result::Err(_) -> Result::Err(f(r.get_unsafe(0)))
	_							-> r
}

to_err = (a) => Result::Err(a)

unwrap = (r:Result) => r.get_unsafe(0)

unwrap_or = (r:Result, a) => match r {
	Result::Ok(_) -> r.get_unsafe(0)
	_							-> a
}



# Maybe type

alias Maybe =
		Maybe::Some(_)
	| Maybe::None

to_maybe = (a) => Maybe::Some(a)

map = (m:Maybe, f:Fn) => match m {
	Maybe::Some(_) -> Maybe::Some(f(m.get_unsafe(0)))
	_							 -> m
}

unwrap = (m:Maybe) => m.get_unsafe(0)

unwrap_or = (m:Maybe, a) => match m {
	Maybe::Some(_) -> m.get_unsafe(0)
	_							 -> a
}



# Smaller types


#
# List
#


length = (list:List) => {
	_length = (l, i) => match l.get(i) {
		Maybe::None -> i
		_ -> _length(l, (i + 1))
	}
	_length(list, 0)
}

map = (list:List, f:Fn) => {
	_map_list = (i) => {
		x = list.get(i)
		match x {
			Maybe::Some(_) -> [f(x.unwrap())] ++ {
				_map_list(i + 1)
			}
			_ -> []
		}
	}
	_map_list(0)
}

# Expects the list to contain only Num
sum = (list:List) => {
	_sum = (l, i, s) => match l.get(i) {
		Maybe::Some(_) -> {
			v = l.get(i)
			newsum = v.unwrap() + s
			_sum(l, (i + 1), newsum)
		}
		_ -> s
	}
	_sum(list, 0, 0)
}


# Num functions

increment = (n:Num) => n + 1

increment_by = (a:Num) => (b:Num) => a + b
